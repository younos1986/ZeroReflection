using System.Linq;
using System.Text;
using System.Collections.Generic;
using ZeroReflection.Mapper.CodeGeneration.Models;
using ZeroReflection.Mapper.CodeGeneration.Utils;

namespace ZeroReflection.Mapper.CodeGeneration.Emit
{
    internal static class MappingHandlerEmitter
    {
        public static string Build(string source, string destination, MappingInfo mapping, List<MappingInfo> allMappings)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Linq;");
            if (mapping is { HasCustomMapping: true, CustomMappingIsStatic: false })
                sb.AppendLine("using System.Reflection;");
            sb.AppendLine("using ZeroReflection.Mapper;");
            if (mapping != null)
            {
                foreach (var ns in CodeGenUtils.GetRequiredNamespaces(new List<MappingInfo> { mapping }))
                    sb.AppendLine($"using {ns};");
            }
            sb.AppendLine();
            sb.AppendLine("namespace ZeroReflection.Mapper.Generated");
            sb.AppendLine("{");
            sb.AppendLine($"    public static class Map{source}To{destination}");
            sb.AppendLine("    {");

            if (mapping != null)
            {
                GenerateMappingMethod(sb, mapping);
            }
            else
            {
                GenerateFallback(sb, source, destination);
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }

        private static void GenerateFallback(StringBuilder sb, string source, string destination)
        {
            var methodName = $"MapTo{destination}";
            sb.AppendLine($"        public static {destination} {methodName}({source} source)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (source == null) return null;");
            sb.AppendLine($"            throw new NotImplementedException(\"Mapping from {source} to {destination} is not implemented\");");
            sb.AppendLine("        }");
        }

        private static void GenerateMappingMethod(StringBuilder sb, MappingInfo mapping)
        {
            var srcQ = CodeGenUtils.Qualify(mapping.SourceNamespace, mapping.Source);
            var dstQ = CodeGenUtils.Qualify(mapping.DestinationNamespace, mapping.Destination);
            var methodName = $"MapTo{mapping.Destination}";

            sb.AppendLine($"        public static {dstQ} {methodName}(this {srcQ} source)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (source == null) return null;");
            sb.AppendLine();

            if (mapping.ThrowIfPropertyMissing)
                GeneratePropertyMappingValidation(sb, mapping);

            if (mapping.HasCustomMapping && !string.IsNullOrEmpty(mapping.CustomMappingMethod))
            {
                sb.AppendLine("            // Using user-defined custom mapping method");
                GenerateCustomMappingInvocation(sb, mapping);
            }
            else
            {
                sb.AppendLine($"            return new {dstQ}");
                sb.AppendLine("            {");
                var mappableProperties = mapping.Properties.Where(p => p.IsMappable).ToList();
                var unmappableProperties = mapping.Properties.Where(p => !p.IsMappable).ToList();
                for (int i = 0; i < mappableProperties.Count; i++)
                {
                    var prop = mappableProperties[i];
                    var comma = i < mappableProperties.Count - 1 ? "," : "";
                    var mappingCode = GeneratePropertyMappingCode(prop);
                    sb.AppendLine($"                {prop.Name} = {mappingCode}{comma}");
                }
                if (unmappableProperties.Any())
                {
                    sb.AppendLine();
                    sb.AppendLine("                // Unmappable properties:");
                    foreach (var unmappableProp in unmappableProperties)
                    {
                        sb.AppendLine($"                // {unmappableProp.Name} ({unmappableProp.Type}): {unmappableProp.UnmappableReason}");
                    }
                }
                sb.AppendLine("            };");
            }
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine($"        public static System.Collections.Generic.List<{dstQ}> MapListTo{mapping.Destination}(System.Collections.Generic.List<{srcQ}> source) => ZeroReflection.Mapper.CodeGeneration.MapCollectionHelpers.MapList<{srcQ},{dstQ}>(source, x => x.MapTo{mapping.Destination}());");
            sb.AppendLine("        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine();
            sb.AppendLine($"        public static {dstQ}[] MapArrayTo{mapping.Destination}({srcQ}[] source)");
            sb.AppendLine("        {");
            sb.AppendLine($"            return ZeroReflection.Mapper.CodeGeneration.MapCollectionHelpers.MapArray<{srcQ},{dstQ}>(source, x => x.MapTo{mapping.Destination}());");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"        public static {dstQ}[] MapListTo{mapping.Destination}Array(System.Collections.Generic.List<{srcQ}> source)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (source == null) return null;");
            sb.AppendLine($"            var result = new {dstQ}[source.Count];");
            sb.AppendLine("            for (int i = 0; i < source.Count; i++)");
            sb.AppendLine($"                result[i] = source[i].MapTo{mapping.Destination}();");
            sb.AppendLine("            return result;");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine($"        public static System.Collections.Generic.List<{dstQ}> MapArrayTo{mapping.Destination}List({srcQ}[] source) => ZeroReflection.Mapper.CodeGeneration.MapCollectionHelpers.MapArrayToList<{srcQ},{dstQ}>(source, x => x.MapTo{mapping.Destination}());");

            if (mapping.EnableProjectionFunctions)
            {
                sb.AppendLine();
                sb.AppendLine("        /// <summary>Expression for single item projection using Map method.</summary>");
                sb.AppendLine($"        public static System.Linq.Expressions.Expression<System.Func<{srcQ}, {dstQ}>> Projection => source => source.MapTo{mapping.Destination}();");
                sb.AppendLine();
                sb.AppendLine("        /// <summary>Expression for List<TSource> projection using list mapping method.</summary>");
                sb.AppendLine($"        public static System.Linq.Expressions.Expression<System.Func<System.Collections.Generic.List<{srcQ}>, System.Collections.Generic.List<{dstQ}>>> ListProjection => list => MapListTo{mapping.Destination}(list);");
                sb.AppendLine();
                sb.AppendLine($"        public static readonly System.Func<System.Collections.Generic.List<{srcQ}>, System.Collections.Generic.List<{dstQ}>> ListProjectionCompiled = ListProjection.Compile();");
                sb.AppendLine();
                sb.AppendLine("        /// <summary>Expression for array projection using array mapping method.</summary>");
                sb.AppendLine($"        public static System.Linq.Expressions.Expression<System.Func<{srcQ}[], {dstQ}[]>> ArrayProjection => array => MapArrayTo{mapping.Destination}(array);");
                sb.AppendLine();
                sb.AppendLine($"        public static readonly System.Func<{srcQ}[], {dstQ}[]> ArrayProjectionCompiled = ArrayProjection.Compile();");
            }
        }

        private static void GenerateCustomMappingInvocation(StringBuilder sb, MappingInfo mapping)
        {
            var profileFullName = mapping.CustomMappingProfileFullName;
            var method = mapping.CustomMappingMethod;
            if (!string.IsNullOrEmpty(profileFullName))
            {
                if (mapping.CustomMappingIsStatic)
                {
                    sb.AppendLine($"            return {profileFullName}.{method}(source);");
                }
                else
                {
                    sb.AppendLine($"            var __profileType = typeof({profileFullName});");
                    sb.AppendLine("            var __instance = Activator.CreateInstance(__profileType);");
                    sb.AppendLine($"            var __method = __profileType.GetMethod(\"{method}\", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);");
                    sb.AppendLine("            if (__method == null) throw new InvalidOperationException(\"Custom mapping method not found: {profileFullName}." + method + "\");");
                    sb.AppendLine($"            return ({mapping.Destination})__method.Invoke(__instance, new object[] {{ source }});");
                }
            }
            else
            {
                sb.AppendLine($"            throw new NotImplementedException(\"Could not resolve custom mapping method '{method}' for {mapping.Source}->{mapping.Destination}\");");
            }
        }

        private static string GeneratePropertyMappingCode(PropertyMapping prop)
        {
            if (prop.IsCustomMapped && !string.IsNullOrEmpty(prop.CustomMappingExpression))
                return prop.CustomMappingExpression;

            switch (prop.MappingType)
            {
                case MappingType.Direct:
                    return $"source.{prop.SourcePropertyName}";
                case MappingType.NullableToNonNullable:
                    return GenerateNullableToNonNullableMapping(prop);
                case MappingType.NonNullableToNullable:
                    return $"source.{prop.SourcePropertyName}";
                case MappingType.Deep:
                    var srcElem = CodeGenUtils.ExtractTypeName(prop.SourceType);
                    var dstElem = CodeGenUtils.ExtractTypeName(prop.Type);
                    return $"source.{prop.SourcePropertyName} == null ? null : Map{srcElem}To{dstElem}.MapTo{dstElem}(source.{prop.SourcePropertyName})";
                case MappingType.CollectionDirect:
                    return GenerateCollectionDirectMapping(prop);
                case MappingType.CollectionDeep:
                    return GenerateCollectionDeepMapping(prop);
                default:
                    return $"source.{prop.SourcePropertyName}";
            }
        }

        private static string GenerateNullableToNonNullableMapping(PropertyMapping prop)
        {
            var src = prop.SourceType;
            var dst = prop.Type;
            if (src.EndsWith("?"))
                return $"source.{prop.SourcePropertyName} ?? {GetDefaultValueForType(dst)}";
            if (src.StartsWith("System.Nullable<") || src.Contains("?"))
                return $"source.{prop.SourcePropertyName} ?? {GetDefaultValueForType(dst)}";
            return $"source.{prop.SourcePropertyName}";
        }

        private static string GetDefaultValueForType(string typeName)
        {
            switch (typeName)
            {
                case "string": return "string.Empty";
                case "int": return "0";
                case "long": return "0L";
                case "double": return "0.0";
                case "float": return "0.0f";
                case "decimal": return "0m";
                case "bool": return "false";
                case "DateTime": return "DateTime.MinValue";
                case "Guid": return "Guid.Empty";
                default:
                    if (typeName.EndsWith("[]")) return "new " + typeName + " { }";
                    if (typeName.StartsWith("List<")) return "new " + typeName + "()";
                    return "default(" + typeName + ")";
            }
        }

        private static string GenerateCollectionDirectMapping(PropertyMapping prop)
        {
            if (prop.Type.Contains("List<"))
            {
                if (prop.SourceType.Contains("List<")) return $"source.{prop.SourcePropertyName}";
                if (prop.SourceType.Contains("[]")) return $"source.{prop.SourcePropertyName}?.ToList()";
            }
            else if (prop.Type.Contains("[]"))
            {
                if (prop.SourceType.Contains("List<")) return $"source.{prop.SourcePropertyName}?.ToArray()";
                if (prop.SourceType.Contains("[]")) return $"source.{prop.SourcePropertyName}";
            }
            return $"source.{prop.SourcePropertyName}";
        }

        private static string GenerateCollectionDeepMapping(PropertyMapping prop)
        {
            var srcElem = CodeGenUtils.ExtractTypeName(prop.SourceCollectionElementType);
            var dstElem = CodeGenUtils.ExtractTypeName(prop.CollectionElementType);
            var mapClass = $"Map{srcElem}To{dstElem}";
            if (prop.Type.Contains("List<"))
                return $"{mapClass}.MapListTo{dstElem}(source.{prop.SourcePropertyName})";
            if (prop.Type.Contains("[]"))
                return $"{mapClass}.MapArrayTo{dstElem}(source.{prop.SourcePropertyName})";
            return $"{mapClass}.MapListTo{dstElem}(source.{prop.SourcePropertyName})";
        }

        private static void GeneratePropertyMappingValidation(StringBuilder sb, MappingInfo mapping)
        {
            var unmappable = mapping.Properties.Where(p => !p.IsMappable && !p.IsCustomMapped).ToList();
            if (unmappable.Any())
            {
                sb.AppendLine("            // Build-time errors for unmapped properties (ThrowIfPropertyMissing=true)");
                foreach (var p in unmappable)
                    sb.AppendLine($"#error ZeroReflection.Mapper: Property mapping missing for '{mapping.Source}->{mapping.Destination}.{p.Name}': {p.UnmappableReason}. Fix the model or add configuration (Ignore/ForMember/WithCustomMapping).");
                sb.AppendLine();
            }
        }
    }
}
